import subprocess
import status
import shlex
from .commands_extra import *

def mAdd(images_table, template_header, out_image, img_dir=None,
          no_area=False, type=None, exact=False, debug_level=None,
          status_file=None, mpi=False, n_proc=8):
    '''
    Coadd the reprojected images in an input list to form an output mosaic
    with FITS header keywords specified in a header file. Creates two output
    files, one containing the coadded pixel values, and the other containing
    coadded pixel area values. The pixel area values can be used as a
    weighting function if the output pixel values are themselves to be coadded
    with other projected images, and may also be used in validating the
    fidelity of the output pixel values.

    Required Arguments:

        *images_table* [ value ]
            ASCII table (generated by mImgtbl) containing metadata for all
            images to be coadded.

        *template_header* [ value ]
            FITS header template to be used in generation of output FITS

        *out_image* [ value ]
            Name of output FITS image.

    Optional Arguments:

        *img_dir* [ value ]
            Specifies path to directory containing reprojected images. If the
            img_dir option is not included, mAdd will look for the input
            images in the current working directory.

        *no_area* [ True | False ]
            Co-addition ignores weighting by pixel areas and performs
            coaddition based only on pixel postions. Will not output an area
            image for the output image.

        *type* [ value ]
            Select type of averaging to be done on accumulated pixel values
            (either mean or median). To generate a map showing counts of how
            man_y times each pixel was overlapped by the input images, use
            count.

        *exact* [ True | False ]
            Enables exact size mode. The output image will match the header
            template exactly, instead of shrinking the output to fit the data.

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *status_file* [ value ]
            mAdd output and errors will be written to status_file instead of
            stdout.

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mAddMPI" % n_proc
    else:
        command = "mAdd"
    if img_dir:
        command += " -p %s" % str(img_dir)
    if no_area:
        command += " -n"
    if type:
        command += " -a %s" % str(type)
    if exact:
        command += " -e"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(template_header)
    command += " " + str(out_image)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mAdd", p.stdout.read().strip())


def mAddExec(images_table, template_header, tile_dir, out_image, img_dir=None,
          no_area=False, type=None, exact=False, debug_level=None,
          status_file=None, mpi=False, n_proc=8):
    '''
    Builds a series of outputs (which together make up a tiled output) through
    multiple executions of the mAdd modules.

    Required Arguments:

        *images_table* [ value ]
            ASCII table (generated by mImgtbl) containing metadata for all
            images to be coadded.

        *template_header* [ value ]
            FITS header template to be used in generation of output FITS

        *tile_dir* [ value ]
            Directory to contain output tile images and header templates

        *out_image* [ value ]
            Prefix for output tile images

    Optional Arguments:

        *img_dir* [ value ]
            Specifies path to directory containing reprojected images. If the
            img_dir option is not included, mAdd will look for the input
            images in the current working directory.

        *no_area* [ True | False ]
            Co-addition ignores weighting by pixel areas and performs
            coaddition based only on pixel postions. Will not output an area
            image for the output image.

        *type* [ value ]
            Select type of averaging to be done on accumulated pixel values
            (either mean or median).

        *exact* [ True | False ]
            Enables exact size mode. The output image will match the header
            template exactly, instead of shrinking the output to fit the data.

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *status_file* [ value ]
            mAdd output and errors will be written to status_file instead of
            stdout.

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mAddExecMPI" % n_proc
    else:
        command = "mAddExec"
    if img_dir:
        command += " -p %s" % str(img_dir)
    if no_area:
        command += " -n"
    if type:
        command += " -a %s" % str(type)
    if exact:
        command += " -e"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(template_header)
    command += " " + str(tile_dir)
    command += " " + str(out_image)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mAddExec", p.stdout.read().strip())


def mArchiveExec(region_table, debug_level=None):
    '''
    Given a table of archive images (generated by mArchiveList), calls
    mArchiveGet on each one in sequence to retrieve all the files into the
    current directory.

    Required Arguments:

        *region_table* [ value ]
            Table of archive images, generated by mArchiveList.

    Optional Arguments:

        *debug_level* [ value ]
            Prints out additional debugging information; in this version, the
            only supported level is 1.
    '''
    command = "mArchiveExec"
    if debug_level:
        command += " -d %s" % str(debug_level)
    command += " " + str(region_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mArchiveExec", p.stdout.read().strip())


def mArchiveGet(remote_ref, local_file, debug=False, raw=False):
    '''
    Retrieve a single FITS image from a remote archive, using a basic URL GET
    but with a structured output.

    Required Arguments:

        *remote_ref* [ value ]
            URL of remote FITS file to retrieve (should be in quotes). See
            mArchiveList for more information.

        *local_file* [ value ]
            Full path/filename of the retrieved file.

    Optional Arguments:

        *debug* [ True | False ]
            Print additional debugging information.

        *raw* [ True | False ]
            "Raw" mode - use a raw HTTP GET (no "HTTP/1.1" etc in the header);
            necessary for communication with some servers.
    '''
    command = "mArchiveGet"
    if debug:
        command += " -d"
    if raw:
        command += " -r"
    command += ' "' + str(remote_ref) + '"'
    command += " " + str(local_file)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mArchiveGet", p.stdout.read().strip())


def mArchiveList(survey, band, object_or_location, width, height, out_file):
    '''
    Given a location on the sky, archive name, and size in degrees, contact
    the IRSA server to retrieve a list of archive images.  The list contains
    enough information to support mArchiveGet downloads.

    Required Arguments:

        *survey* [ value ]
            Can be one of: 2MASS DSS SDSS DPOSS

        *band* [ value ]
            Case insensitive - can be one of: (2MASS) j, h, k (SDSS) u, g, r,
            i, z (DPOSS) f, j, n (DSS) DSS1, DSS1R, DSS1B, DSS2, DSS2B, DSS2R,
            DSS2IR

        *object_or_location* [ value ]
            Object name or coordinate string to be resolved by NED (if string
            includes spaces, must be surrounded by double quotes)

        *width* [ value ]
            Width of area of interest, in degrees

        *height* [ value ]
            Height of area of interest, in degrees

        *out_file* [ value ]
            Path to output table
    '''
    command = "mArchiveList"
    command += " " + str(survey)
    command += " " + str(band)
    command += ' "' + str(object_or_location) + '"'
    command += " " + str(width)
    command += " " + str(height)
    command += " " + str(out_file)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mArchiveList", p.stdout.read().strip())


def mBackground(in_image, out_image, A, B, C, debug_level=None, no_area=False,
          status_file=None):
    '''
    Remove a background plane from a FITS image.  The background correction
    applied to the image is specified as Ax+By+C, where (x,y) is the pixel
    coordinate using the image center as the origin, and (A,B,C) are the
    background plane parameters specified as linear coefficients. To run in
    'table' mode, see mBackground_tab.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file

        *out_image* [ value ]
            Output FITS file

        *A, B, C* [ value ]
            Corrections (as given by mFitplane or mFitExec)

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level.

        *no_area* [ True | False ]
            Indicates that no area images are present (assumes equal weighting
            for each data pixel)

        *status_file* [ value ]
            mBackground output and errors will be written to status_file
            instead of stdout.
    '''
    command = "mBackground"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if no_area:
        command += " -n"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(A)
    command += " " + str(B)
    command += " " + str(C)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mBackground", p.stdout.read().strip())


def mBackground_tab(in_image, out_image, images_table, corrections_table,
          debug_level=None, no_area=False, status_file=None):
    '''
    Remove a background plane from a FITS image.  The background correction
    applied to the image is specified as Ax+By+C, where (x,y) is the pixel
    coordinate using the image center as the origin, and (A,B,C) are the
    background plane parameters specified as linear coefficients. This method
    runs mBackground_tab in 'table' mode.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file

        *out_image* [ value ]
            Output FITS file

        *images_table* [ value ]
            Image metadata table to retrieve the filenames of images.

        *corrections_table* [ value ]
            Table of corrections (from mFitplane and mFitExec) to apply to the
            corresponding image (from images_table).

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level.

        *no_area* [ True | False ]
            Indicates that no area images are present (assumes equal weighting
            for each data pixel)

        *status_file* [ value ]
            mBackground_tab output and errors will be written to status_file
            instead of stdout.
    '''
    command = "mBackground_tab"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if no_area:
        command += " -n"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(images_table)
    command += " " + str(corrections_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mBackground_tab", p.stdout.read().strip())


def mBestImage(images_table, ra, dec, debug_level=None):
    '''
    Given a list of images and a position on the sky, determine which image
    covers the location "best" (i.e., the one where the position is farthest
    from the nearest edge).

    Required Arguments:

        *images_table* [ value ]
            Input table of image metadata (as generated by mImgtbl).

        *ra* [ value ]
            RA of location of interest (in degrees)

        *dec* [ value ]
            Declination of location of interest (in degrees)

    Optional Arguments:

        *debug_level* [ value ]
            Turn on debugging to the specified level (1 or 2)
    '''
    command = "mBestImage"
    if debug_level:
        command += " -d %s" % str(debug_level)
    command += " " + str(images_table)
    command += " " + str(ra)
    command += " " + str(dec)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mBestImage", p.stdout.read().strip())


def mBgExec(images_table, corrections_table, corr_dir, proj_dir=None,
          status_file=None, debug=False, no_area=False, mpi=False, n_proc=8):
    '''
    Runs mBackground on all the images in a metadata table, using the
    corrections generated by mFitExec.

    Required Arguments:

        *images_table* [ value ]
            Image metadata table generated by mImgtbl.

        *corrections_table* [ value ]
            Table of corrections generated by mFitExec

        *corr_dir* [ value ]
            Directory where output images should be written

    Optional Arguments:

        *proj_dir* [ value ]
            Specifies the path to the directory containing the projected
            images.

        *status_file* [ value ]
            Writes output message to status_file instead of to stdout

        *debug* [ True | False ]
            Turns on debugging

        *no_area* [ True | False ]
            Indicates that no area images are present (assumes equal weighting
            for each pixel)

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mBgExecMPI" % n_proc
    else:
        command = "mBgExec"
    if proj_dir:
        command += " -p %s" % str(proj_dir)
    if status_file:
        command += " -s %s" % str(status_file)
    if debug:
        command += " -d"
    if no_area:
        command += " -n"
    command += " " + str(images_table)
    command += " " + str(corrections_table)
    command += " " + str(corr_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mBgExec", p.stdout.read().strip())


def mBgModel(images_table, fits_table, corrections_table, n_iter=None,
          level_only=False, debug_level=None, ref_img=None, status_file=None):
    '''
    mBgModel is a modelling/fitting program.  It uses the image-to-image
    difference parameter table created by mFitExec to interactively determine
    a set of corrections to apply to each image in order to achieve a "best"
    global fit.

    Required Arguments:

        *images_table* [ value ]
            Image metadata table generated by mImgtbl.

        *fits_table* [ value ]
            Plane fitting table generated by mFitExec.

        *corrections_table* [ value ]
            Output table of background corrections

    Optional Arguments:

        *n_iter* [ value ]
            Number of iterations (without option, defaults to 5000). Can be
            between 1 and 32767.

        *level_only* [ True | False ]
            Calculate level adjustments only (ie, don't attempt to match the
            slopes)

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *ref_img* [ value ]
            Turns on additional debugging for the nth image in images_table.

        *status_file* [ value ]
            mBgModel output and errors are written to status_file instead of
            to stdout.
    '''
    command = "mBgModel"
    if n_iter:
        command += " -i %s" % str(n_iter)
    if level_only:
        command += " -l"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if ref_img:
        command += " -r %s" % str(ref_img)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(fits_table)
    command += " " + str(corrections_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mBgModel", p.stdout.read().strip())


def mCatMap(in_table, out_image, template_header, column=None, ref_mag=None,
          debug_level=None, size=None):
    '''
    mCatMap is a point-source imaging program.  The user defines a general
    output FITS image, and its pixels are populated from a table of point
    sources.  The source fluxes (or just source counts) from the table are
    added into the appropriate pixel to create an output image.

    Required Arguments:

        *in_table* [ value ]
            Input table of source metadata.

        *out_image* [ value ]
            Path of output FITS file.

        *template_header* [ value ]
            ASCII header template defining output FITS file.

    Optional Arguments:

        *column* [ value ]
            Name of the table column that contains flux levels. If not
            specified, pixels will be populated with source counts rather than
            summed flux values.

        *ref_mag* [ value ]
            Set a reference magnitude to use when calculating fluxes.

        *debug_level* [ value ]
            Turn on debugging to the specified level (1-3)

        *size* [ value ]
            Set a spread size for point sources (default is to use no spread).
            Allowed values are 3 or 5.
    '''
    command = "mCatMap"
    if column:
        command += " -c %s" % str(column)
    if ref_mag:
        command += " -m %s" % str(ref_mag)
    if debug_level:
        command += " -d %s" % str(debug_level)
    if size:
        command += " -w %s" % str(size)
    command += " " + str(in_table)
    command += " " + str(out_image)
    command += " " + str(template_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mCatMap", p.stdout.read().strip())


def mConvert(in_image, out_image, debug_level=None, status_file=None,
          bitpix=None, min_val=None, max_val=None, blank_value=None):
    '''
    mConvert changes the datatype of an image.  When converting to floating
    point, no additional information is needed.  However, when converting from
    higher precision (e.g. 64-bit floating point) to lower (e.g. 16-bit
    integer), scaling information is necessary.  This can be given explicitly
    by the user or guessed by the program.

    Required Arguments:

        *in_image* [ value ]
            Input image filename

        *out_image* [ value ]
            Output image filename.

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *status_file* [ value ]
            mBgModel output and errors are written to status_file instead of
            to stdout.

        *bitpix* [ value ]
            BITPIX value for the ouput FITS file (default is -64). Possible
            values are: 8 (character or unsigned binary integer), 16 (16-bit
            integer), 32 (32-bit integer), -32 (single precision floating
            point), -64 (double precision floating point).

        *min_val* [ value ]
            Pixel data value in the input image which should be treated as a
            minimum (value of 0) in the output image when converting from
            floating point to integer (default for BITPIX 8: 0; BITPIX 16:
            -32767; BITPIX 32: -2147483647

        *max_val* [ value ]
            Pixel data value in the input image which should be treated as a
            maximum (value of 255 or 32768) in the output image when
            converting from floating point to integer (Default for BITPIX 8:
            255; BITPIX 16: 32768; BITPIX 32: 2147483648)

        *blank_value* [ value ]
            If converting down to an integer scale: value to be used in the
            output image to represent blank pixels (NaN) from the input image.
            Default value is min_val.
    '''
    command = "mConvert"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    if bitpix:
        command += " -b %s" % str(bitpix)
    if min_val:
        command += " -min %s" % str(min_val)
    if max_val:
        command += " -max %s" % str(max_val)
    if blank_value:
        command += " -blank %s" % str(blank_value)
    command += " " + str(in_image)
    command += " " + str(out_image)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mConvert", p.stdout.read().strip())


def mDiff(in_image_1, in_image_2, out_image, template_header,
          debug_level=None, no_area=False, status_file=None):
    '''
    mDiff calculates a simple difference between a single pair of overlapping
    images. This is meant for use on reprojected images where the pixels
    already line up exactly. mDiff analyzes an image metadata table to
    determine a list of overlapping images.  Each image is compared with every
    other image to determine all overlapping image pairs.  A pair of images
    are deemed to overlap if any pixel around the perimeter of one image falls
    within the boundary of the other image.

    Required Arguments:

        *in_image_1* [ value ]
            First input FITS file (Also needs area image in1_area_image, or
            use the no_area option)

        *in_image_2* [ value ]
            Second input FITS file.(Also needs area image in2_area_image, or
            use the no_area option)

        *out_image* [ value ]
            Difference FITS image to be generated.

        *template_header* [ value ]
            FITS header template used to generate output image.

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-4).

        *no_area* [ True | False ]
            No-area-images option. Creates difference image without requiring
            pixel area FITS image

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mDiff"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if no_area:
        command += " -n"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image_1)
    command += " " + str(in_image_2)
    command += " " + str(out_image)
    command += " " + str(template_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mDiff", p.stdout.read().strip())


def mDiffExec(diffs_table, template_header, diff_dir, proj_dir=None,
          debug=False, no_area=False, status_file=None, mpi=False, n_proc=8):
    '''
    Runs mDiff on all the pairs identified by mOverlaps.

    Required Arguments:

        *diffs_table* [ value ]
            Table generated by mOverlaps for the images in proj_dir.

        *template_header* [ value ]
            FITS header template for output files.

        *diff_dir* [ value ]
            Path to output files.

    Optional Arguments:

        *proj_dir* [ value ]
            Specifies path to the directory containing reprojected input
            images.

        *debug* [ True | False ]
            Turns on debugging.

        *no_area* [ True | False ]
            No-area-images option. Creates difference image without requiring
            _area FITS images

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mDiffExecMPI" % n_proc
    else:
        command = "mDiffExec"
    if proj_dir:
        command += " -p %s" % str(proj_dir)
    if debug:
        command += " -d"
    if no_area:
        command += " -n"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(diffs_table)
    command += " " + str(template_header)
    command += " " + str(diff_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mDiffExec", p.stdout.read().strip())


def mDiffFitExec(diffs_table, fits_table, diff_dir, debug=False,
          status_file=None):
    '''
    Using the table of overlaps found by mOverlaps, mDiffFitExec runs both
    mDiff and mFitplane for each record.  The fitting parameters are written
    to a file to be used by mBgModel.

    Required Arguments:

        *diffs_table* [ value ]
            Overlap table generated by mOverlaps, the last column of which
            contains the filenames of the difference images generated by
            mDiffExec.

        *fits_table* [ value ]
            Output table of difference paramaters.

        *diff_dir* [ value ]
            Directory containing difference images.

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging

        *status_file* [ value ]
            Writes output message to status_file instead of to stdout
    '''
    command = "mDiffFitExec"
    if debug:
        command += " -d"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(diffs_table)
    command += " " + str(fits_table)
    command += " " + str(diff_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mDiffFitExec", p.stdout.read().strip())


def mExec(survey, band, raw_dir=None, n_tile_x=None, n_tile_y=None,
          level_only=False, keep=False, corners=False, output_image=None,
          debug_level=None, region_header=None, header=None,
          workspace_dir=None):
    '''
    The mExec module is a mosaicking executive for 2MASS, SDSS, and DSS data.
    It includes remote data and metadata access.  Alternatively, users can
    mosaic a set of data already on disk.

    Required Arguments:

        *survey, band* [ value ]
            If not mosaicking user-provided data (raw_dir option), must select
            one of the following combinations of survey and band: 2MASS [j, h,
            k] SDSS [u, g, r, i, z] DSS [DSS1, DSS1R, DSS1B, DSS2, DSS2B,
            DSS2R, DSS2IR]

    Optional Arguments:

        *raw_dir* [ value ]
            Provide path to directory containing original ("raw") data which
            will be reprojected and mosaicked. Not necessary if using mExec to
            retrieve remote data from the 2MASS, SDSS or DSS surveys.

        *n_tile_x* [ value ]
            Number of output tiles to create along the X-axis - default is 1
            for a single mosaicked image.

        *n_tile_y* [ value ]
            Number of output tiles to create along the Y-axis - default is
            equal to n_tile_x.

        *level_only* [ True | False ]
            "Level-only" option (see mBgModel)

        *keep* [ True | False ]
            If retrieving data from a remote archive, the "keep" option will
            leave the original data products on disk after generating a
            mosaic. Without this option, raw data will be deleted (unless it
            was provided by the user with the "-r" option).

        *corners* [ True | False ]
            Remove all temporary files and intermediate data products. Note:
            if not using the '-o' option to specify an output file, this will
            also remove mosaic_image.

        *output_image* [ value ]
            Provide your own filename for the output mosaic. Default filename
            is "mosaic_image."

        *debug_level* [ value ]
            Print out additional debugging information (levels 1-4)

        *region_header* [ value ]
            Path to header template used to create mosaic.

        *header* [ value ]
            Provide header template as text input rather than point to a file;
            see sample shell script that makes use of this option.

        *workspace_dir* [ value ]
            Directory where intermediate files will be created. If no
            workspace is given, a unique local subdirectory will be created
            (e.g.; ./MOSAIC_AAAaa17v)
    '''
    command = "mExec"
    if raw_dir:
        command += " -r %s" % str(raw_dir)
    if n_tile_x:
        command += " -n %s" % str(n_tile_x)
    if n_tile_y:
        command += " -m %s" % str(n_tile_y)
    if level_only:
        command += " -l"
    if keep:
        command += " -k"
    if corners:
        command += " -c"
    if output_image:
        command += " -o %s" % str(output_image)
    if debug_level:
        command += " -d %s" % str(debug_level)
    if region_header:
        command += " -f %s" % str(region_header)
    if header:
        command += " -h %s" % str(header)
    command += " " + str(survey)
    command += " " + str(band)
    if workspace_dir:
        command += " %s" % str(workspace_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mExec", p.stdout.read().strip())


def mFitExec(diffs_table, fits_table, diff_dir, debug=False, status_file=None,
          mpi=False, n_proc=8):
    '''
    Runs mFitplane on all the difference images identified by mOverlaps and
    generated by mDiff or mDiffExec. mFitExec creates a table of image-to-
    image difference parameters.

    Required Arguments:

        *diffs_table* [ value ]
            Overlap table generated by mOverlaps, the last column of which
            contains the filenames of the difference images generated by
            mDiffExec.

        *fits_table* [ value ]
            Output table of difference paramaters.

        *diff_dir* [ value ]
            Directory containing difference images.

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging

        *status_file* [ value ]
            Writes output message to status_file instead of to stdout

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mFitExecMPI" % n_proc
    else:
        command = "mFitExec"
    if debug:
        command += " -d"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(diffs_table)
    command += " " + str(fits_table)
    command += " " + str(diff_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mFitExec", p.stdout.read().strip())


def mFitplane(in_image, border=None, debug_level=None, status_file=None):
    '''
    Uses least squares to fit a plane (excluding outlier pixels) to an image.
    It is used on the difference images generated using mDiff or mDiffExec.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file is a difference file between two other FITS files,
            as can be generated using mDiff.

    Optional Arguments:

        *border* [ value ]
            Number of border pixels to ignore at edges of image.

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *status_file* [ value ]
            Output and errors are written to status_file instead of stdout.
    '''
    command = "mFitplane"
    if border:
        command += " -b %s" % str(border)
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mFitplane", p.stdout.read().strip())


def mFixNan(in_image, out_image, debug_level=None, nan_value=None,
          min_blank=None, max_blank=None):
    '''
    Converts NaNs found in the image to some other value (given by the user),
    or converts a range of supplied values into NaNs.

    Required Arguments:

        *in_image* [ value ]
            Input FITS image file

        *out_image* [ value ]
            Path of output FITS file. To run in "count" mode without creating
            an output file, use a dash ("-") for this argument.

    Optional Arguments:

        *debug_level* [ value ]
            Turn on debugging to the specified level (1-3)

        *nan_value* [ value ]
            Value to use in place of an_y NaNs

        *min_blank, max_blank* [ value ]
            If the nan_value option is not used, mFixNaN will replace all
            pixel values between min_blank and max_blank with NaN.
    '''
    command = "mFixNan"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if nan_value:
        command += " -v %s" % str(nan_value)
    command += " " + str(in_image)
    command += " " + str(out_image)
    if min_blank and max_blank:
        command += " %s" % str(min_blank)
        command += " %s" % str(max_blank)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mFixNan", p.stdout.read().strip())


def mFlattenExec(images_table, flat_dir, img_dir=None, debug=False,
          no_area=False, status_file=None):
    '''
    Runs both mFitPlane and mBackground on a set of images.

    Required Arguments:

        *images_table* [ value ]
            Metadata table (generated by mImgtbl) describing images to be
            flattened.

        *flat_dir* [ value ]
            Path to directory where output files should be created.

    Optional Arguments:

        *img_dir* [ value ]
            Specifies path to directory containing images to be flattened.

        *debug* [ True | False ]
            Turns on debugging.

        *no_area* [ True | False ]
            No-area-images option, indicating that mFlattenExec should not
            require area images for all the input FITS images.

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mFlattenExec"
    if img_dir:
        command += " -p %s" % str(img_dir)
    if debug:
        command += " -d"
    if no_area:
        command += " -n"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(flat_dir)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mFlattenExec", p.stdout.read().strip())


def mGetHdr(in_image, img_header, debug=False, hdu=None, status_file=None):
    '''
    Reads in the header from a FITS image and prints it out to a text file.

    Required Arguments:

        *in_image* [ value ]
            Path to FITS image from which to retrieve the header.

        *img_header* [ value ]
            Path to text file where FITS header should be written.

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging.

        *hdu* [ value ]
            Retrieve the header from the Fits extention given by hdu. "0"
            indicates the primary FITS extension, and is the default used by
            mGetHdr.

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mGetHdr"
    if debug:
        command += " -d"
    if hdu:
        command += " -h %s" % str(hdu)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(img_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mGetHdr", p.stdout.read().strip())


def mHdr(object_or_location, width, out_file, system=None, equinox=None,
          height=None, pix_size=None, rotation=None):
    '''
    Connects to the IRSA service HdrTemplate to create a header template based
    on a location, size, resolution and rotation.

    Required Arguments:

        *object_or_location* [ value ]
            Object string or coordinate location

        *width* [ value ]
            Width (x-axis) of area

        *out_file* [ value ]
            Path to output header template

    Optional Arguments:

        *system* [ value ]
            Specify a coordinate system. Can be one of: "equatorial" or "eq"
            (default), "ecliptic" or "ec" "galactic", "ga", "supergalactic" or
            "sgal"

        *equinox* [ value ]
            Specify an equinox. Default is 2000.0

        *height* [ value ]
            Height (y-axis) of area in degrees. Default is equal to width

        *pix_size* [ value ]
            Size of a pixel (in arcsec); default is 1

        *rotation* [ value ]
            Rotation of image; default is 0
    '''
    command = "mHdr"
    if system:
        command += " -s %s" % str(system)
    if equinox:
        command += " -e %s" % str(equinox)
    if height:
        command += " -h %s" % str(height)
    if pix_size:
        command += " -p %s" % str(pix_size)
    if rotation:
        command += " -r %s" % str(rotation)
    command += ' "' + str(object_or_location) + '"'
    command += " " + str(width)
    command += " " + str(out_file)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mHdr", p.stdout.read().strip())


def mHdrCheck(in_image, status_file=None):
    '''
    mHdrCheck reads in the header from a FITS image (or an ASCII header
    template file) and checks to see if any header lines are invalid.  If it
    finds one, it will print out a message stating which keyword is invalid
    and exit before checking the rest of the header.  It will not report on
    multiple invalid values.  If all value are correct, mHdrCheck will print
    out a "Valid FITS/WCS" message.

    Required Arguments:

        *in_image* [ value ]
            Path of FITS file to be validated.

    Optional Arguments:

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mHdrCheck"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mHdrCheck", p.stdout.read().strip())


def mHdrtbl(directory, images_table, recursive=False, corners=False,
          debug=False, output_invalid=False, status_file=None, img_list=None):
    '''
    mHdrtbl operates in a fashion similar to mImgtbl, but is used on a set of
    header template files instead of FITS images.

    Required Arguments:

        *directory* [ value ]
            Path to directory containing set of input header templates.

        *images_table* [ value ]
            Path of output metadata table.

    Optional Arguments:

        *recursive* [ True | False ]
            mHdrtbl can also be used as a standalone program to gather image
            metadata for other purposes (to populate a database, as a basis
            for spatial coverage searches, etc.) In this case it is often
            desirable to collect information on all the files in a directory
            tree recursively. The recursive option instructs mHdrtbl to search
            the given directory and all its subdirectories recursively.

        *corners* [ True | False ]
            The corners option in mHdrtbl will cause eight extra columns to be
            added to the output metadata table containing the RA, Dec
            coordinates (ra1, dec1, ... ra4, dec4) of the image corners. The
            output is always Equatorial J2000, even if the input is some other
            system. This has been done to make the metadata uniform so that it
            can easily be used for coverage searches, etc. The corners option
            is not needed for normal Montage processing.

        *debug* [ True | False ]
            Turn on debugging

        *output_invalid* [ True | False ]
            When this option is set, mHdrtbl will explicitly output each
            header file it finds that does not appear to be valid, along with
            information on the error.

        *status_file* [ value ]
            Output and errors are written to status_file instead of being
            written to stdout.

        *img_list* [ value ]
            mHdrtbl will only process files with names specified in table
            img_list, ignoring an_y other files in the directory.
    '''
    command = "mHdrtbl"
    if recursive:
        command += " -r"
    if corners:
        command += " -c"
    if debug:
        command += " -d"
    if output_invalid:
        command += " -b"
    if status_file:
        command += " -s %s" % str(status_file)
    if img_list:
        command += " -t %s" % str(img_list)
    command += " " + str(directory)
    command += " " + str(images_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mHdrtbl", p.stdout.read().strip())


def mImgtbl(directory, images_table, recursive=False, corners=False,
          include_area=False, debug=False, output_invalid=False,
          status_file=None, fieldlist=None, img_list=None):
    '''
    mImgtbl extracts the FITS header geometry information from a set of files
    and creates an ASCII image metadata table which is used by several of the
    other programs.  It only collects data from headers that comply with the
    FITS standard, but reports a count of images that fail that check.

    Required Arguments:

        *directory* [ value ]
            Path to directory containing set of input FITS files.

        *images_table* [ value ]
            Path of output metadata table.

    Optional Arguments:

        *recursive* [ True | False ]
            mImgtbl can also be used as a standalone program to gather image
            metadata for other purposes (to populate a database, as a basis
            for spatial coverage searches, etc.) In this case it is often
            desirable to collect information on all the files in a directory
            tree recursively. The recursive option instructs mImgtbl to search
            the given directory and all its subdirectories recursively.

        *corners* [ True | False ]
            The corners option in mImgtbl will cause eight extra columns to be
            added to the output metadata table containing the RA, Dec
            coordinates (ra1, dec1, ... ra4, dec4) of the image corners. The
            output is always Equatorial J2000, even if the input is some other
            system. Though not required for the core processing modules, we
            recommend using this option, as some of the utilities may require
            corner locations to function properly.

        *include_area* [ True | False ]
            By default, mImgtbl ignores FITS files with names ending in _area
            (i.e. name_area_image), assuming them to be Montage-created area
            images. If you want to generate information on these images, or if
            you have images with _area in the title other than those generated
            by Montage, you should turn on this option to force mImgtbl to
            look at all images in the directory.

        *debug* [ True | False ]
            Turn on debugging

        *output_invalid* [ True | False ]
            When this option is set, mImgtbl will explicitly output each FITS
            file it finds that does not appear to be valid, along with
            information on the error.

        *status_file* [ value ]
            Output and errors are written to status_file instead of being
            written to stdout.

        *fieldlist* [ value ]
            Used to specify a fieldlist, which will list additional keywords
            to be read from the FITS headers and included in the output table.
            Fieldlists should specify the keyword name, type
            (int,char,double), and size.

        *img_list* [ value ]
            mImgtbl will only process files with names specified in table
            img_list, ignoring an_y other files in the directory.
    '''
    command = "mImgtbl"
    if recursive:
        command += " -r"
    if corners:
        command += " -c"
    if include_area:
        command += " -a"
    if debug:
        command += " -d"
    if output_invalid:
        command += " -b"
    if status_file:
        command += " -s %s" % str(status_file)
    if fieldlist:
        command += " -f %s" % str(fieldlist)
    if img_list:
        command += " -t %s" % str(img_list)
    command += " " + str(directory)
    command += " " + str(images_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mImgtbl", p.stdout.read().strip())


def mMakeHdr(images_table, template_header, debug_level=None,
          status_file=None, cdelt=None, north_aligned=False, system=None,
          equinox=None):
    '''
    From a list of images to be mosaicked together, mMakeHdr generates the
    FITS header that best describes the output image.

    Required Arguments:

        *images_table* [ value ]
            Metadata table (generated by mImgtbl) describing the images to be
            mosaicked.

        *template_header* [ value ]
            Path to header template to be generated.

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *status_file* [ value ]
            Output and errors are written to status_file instead of to stdout.

        *cdelt* [ value ]
            Specify a pixel scale for the header, if different from the input
            images

        *north_aligned* [ True | False ]
            "North-aligned" option. By default, the FITS header generated
            represents the best fit to the images, often resulting in a slight
            rotation. If you want north to be straight up in your final
            mosaic, you should use this option.

        *system* [ value ]
            Specifies the system for the header (default is Equatorial).
            Possible values are: EQUJ EQUB ECLJ ECLB GAL SGAL

        *equinox* [ value ]
            If a coordinate system is specified, the equinox can also be given
            in the form YYYY. Default is J2000.
    '''
    command = "mMakeHdr"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    if cdelt:
        command += " -p %s" % str(cdelt)
    if north_aligned:
        command += " -n"
    command += " " + str(images_table)
    command += " " + str(template_header)
    if system:
        command += " %s" % str(system)
        if equinox:
            command += " %s" % str(equinox)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mMakeHdr", p.stdout.read().strip())


def mOverlaps(images_table, diffs_table, exact=False, debug_level=None,
          status_file=None):
    '''
    Analyze an image metadata table to determine a list of overlapping images.
    Each image is compared with every other image to determine all overlapping
    image pairs.  A pair of images are deemed to overlap if any pixel around
    the perimeter of one image falls within the boundary of the other image.

    Required Arguments:

        *images_table* [ value ]
            Table of image metadata generated by mImgtbl.

        *diffs_table* [ value ]
            Path of output table to be generated containing overlap
            information.

    Optional Arguments:

        *exact* [ True | False ]
            Enables 'exact' overlaps mode, as opposed to the default
            approximate algorithm. The default mode uses great-circle
            connecting lines between image corners to determine which images
            overlap. Exact mode will instead check the edge pixels of every
            image to determine which pixels are inside the others. Although
            the default mode will occasionally report some incorrect overlaps,
            this is not a concern since mDiff will detect and ignore these
            false positive results when processing the table.

        *debug_level* [ value ]
            Turns on debugging to the specified level (1 or 2)

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mOverlaps"
    if exact:
        command += " -e"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(diffs_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mOverlaps", p.stdout.read().strip())


def mPix2Coord(template_header, ixpix, jypix, debug=False):
    '''
    Takes an image FITS header template and a pixel (x,y) coordinate, and
    outputs the corresponding sky location.

    Required Arguments:

        *template_header* [ value ]
            ASCII header template describing the image (either a FITS image,
            or a JPEG file created from the FITS file)

        *ixpix* [ value ]
            X coordinate (pixel location) on image

        *jypix* [ value ]
            Y coordinate (pixel location) on image

    Optional Arguments:

        *debug* [ True | False ]
            Print out additional debugging information
    '''
    command = "mPix2Coord"
    if debug:
        command += " -d"
    command += " " + str(template_header)
    command += " " + str(ixpix)
    command += " " + str(jypix)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mPix2Coord", p.stdout.read().strip())


def mProject(in_image, out_image, template_header, factor=None,
          debug_level=None, status_file=None, hdu=None, scale=None,
          weight_file=None, threshold=None, whole=False):
    '''
    mProject reprojects a single image to the scale defined in a FITS header
    template file (read more about header templates here). The program
    produces a pair of images: the reprojected image and an "area" image
    consisting of the fraction input pixel sky area that went into each output
    pixel.  The "drizzle" algorithm is implemented.  The algorithm proceeds by
    mapping pixel corners (as adjusted by drizzle, if called) from the input
    pixel space to the output pixel space, calculating overlap area with each
    output pixel, and accumulating an appropriate fraction of the input flux
    into the output image pixels.  In addition, the appropriate fraction of
    the input pixel area is accumulated into the area image pixels.
    Projection of points from input pixel space to output pixel space is
    calculated in two steps: first map from input pixel space to sky
    coordinates; second map from sky coordinates to output pixel space.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file to be reprojected.

        *out_image* [ value ]
            Path of output FITS file to be created.

        *template_header* [ value ]
            FITS header template to be used in generation of output image

    Optional Arguments:

        *factor* [ value ]
            Processing is done utilizing the drizzle algorithm. factor is a
            floating point number; recommended drizzle factors are from 0.5 to
            1.

        *debug_level* [ value ]
            Causes additional debugging information to be printed to stdout.
            Valid levels are 1-5 (for higher debugging levels, it is
            recommended to redirect the output to a file).

        *status_file* [ value ]
            Output and errors are written to status_file instead of being
            written to stdout.

        *hdu* [ value ]
            Use the specified FITS extension (default is to use the first HDU
            with image data)

        *scale* [ value ]
            Apply a correction factor of scale to each pixel

        *weight_file* [ value ]
            Path to a weight map to be used when reading values from the input
            image.

        *threshold* [ value ]
            Pixels with weights below threshold will be treated as blank.

        *whole* [ True | False ]
            Makes the output region (originally defined in the header
            template) big enough to include all of the input images
    '''
    command = "mProject"
    if factor:
        command += " -z %s" % str(factor)
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    if hdu:
        command += " -h %s" % str(hdu)
    if scale:
        command += " -x %s" % str(scale)
    if weight_file:
        command += " -w %s" % str(weight_file)
    if threshold:
        command += " -t %s" % str(threshold)
    if whole:
        command += " -X"
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(template_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mProject", p.stdout.read().strip())


def mProjectPP(in_image, out_image, template_header, factor=None,
          debug_level=None, border=None, status_file=None,
          alternate_header=None, hdu=None, scale=None, weight_file=None,
          threshold=None, whole=False):
    '''
    mProjectPP reprojects a single image to the scale defined in an alternate
    FITS header template generated (usually) by mTANhdr. The program produces
    a pair of images: the reprojected image and an "area" image consisting of
    the fraction input pixel sky area that went into each output pixel.  This
    area image goes through all the subsequent processing that the reprojected
    image does, allowing it to be properly coadded at the end.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file to be reprojected.

        *out_image* [ value ]
            Path to output FITS file to be created.

        *template_header* [ value ]
            FITS header template to be used in generation of output FITS

    Optional Arguments:

        *factor* [ value ]
            Processing is done utilizing the drizzle algorithm. factor is a
            floating point number; recommended drizzle factors are from 0.5 to
            1.

        *debug_level* [ value ]
            Causes additional debugging information to be printed to stdout.
            Valid levels are 1-5; for levels greater than 1, it's recommended
            to redirect the output into a text file.

        *border* [ value ]
            Ignores border pixels around the image edge when performing
            calculations.

        *status_file* [ value ]
            Output and errors are written to status_file instead of being
            written to stdout.

        *alternate_header* [ value ]
            Specifies an alternate FITS header for use in mProjectPP
            calculations, allows substitution of psuedo-TAN headers created by
            mTANHdr.

        *hdu* [ value ]
            Specify the FITS extension to re-project if the FITS image is
            multi-extension.

        *scale* [ value ]
            Multiple the pixel values by scale when reprojecting. For
            instance, each 2MASS image has a different scale factor (very near
            1.0) to correct for varying magnitude-zero points.

        *weight_file* [ value ]
            Path to a weight map to be used when reading values from the input
            image.

        *threshold* [ value ]
            If using a weight image; only use those pixels where the weight
            value is above threshold.

        *whole* [ True | False ]
            Reproject the whole image even if part of it is outside the region
            of interest (don't crop while re-projecting).
    '''
    command = "mProjectPP"
    if factor:
        command += " -z %s" % str(factor)
    if debug_level:
        command += " -d %s" % str(debug_level)
    if border:
        command += " -b %s" % str(border)
    if status_file:
        command += " -s %s" % str(status_file)
    if alternate_header:
        command += " -[i|o] %s" % str(alternate_header)
    if hdu:
        command += " -h %s" % str(hdu)
    if scale:
        command += " -x %s" % str(scale)
    if weight_file:
        command += " -w %s" % str(weight_file)
    if threshold:
        command += " -t %s" % str(threshold)
    if whole:
        command += " -X"
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(template_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mProjectPP", p.stdout.read().strip())


def mProjExec(images_table, template_header, proj_dir, stats_table,
          raw_dir=None, debug=False, exact=False, whole=False, border=None,
          restart_rec=None, status_file=None, scale_column=None, mpi=False,
          n_proc=8):
    '''
    An executive which runs mProject (or, if possible for the input/output
    projections, mProjectPP) for each image in an image metadata table.

    Required Arguments:

        *images_table* [ value ]
            ASCII table (generated by mImgtbl) containing metadata for all
            images to be reprojected.

        *template_header* [ value ]
            FITS header template to be used in generation of output FITS.

        *proj_dir* [ value ]
            Directory in which to create reprojected images.

        *stats_table* [ value ]
            Name of table for output statistics (time of each reprojection, or
            error messages).

    Optional Arguments:

        *raw_dir* [ value ]
            Specifies the path to the directory containing the images to be
            reprojected. If the -p option is not included, mProjExec looks for
            the images in the current working directory.

        *debug* [ True | False ]
            Turns on debugging

        *exact* [ True | False ]
            Flag indicating output image should exactly match the FITS header
            template, and not crop off blank pixels

        *whole* [ True | False ]
            Force reprojection of whole images, even if they exceed the area
            of the FITS header template

        *border* [ value ]
            Ignore border width of pixels around edge of images

        *restart_rec* [ value ]
            Allows restart at record number restart_rec, if mProjExec exits
            upon an error

        *status_file* [ value ]
            Output and errors are written to status_file instead of being
            written to stdout.

        *scale_column* [ value ]
            Turn on flux rescaling (e.g. magnitude zero point correction):
            scale_column is the name of a column in images_table which
            contains scale information.

        *mpi* [ True | False ]
            If set to True, will use the MPI-enabled versions of the Montage
            executable.

        *n_proc* [ value ]
            If mpi is set to True, n_proc is the number of processes to run
            simultaneously (default is 8)
    '''
    if mpi:
        command = "mpirun -n %i mProjExecMPI" % n_proc
    else:
        command = "mProjExec"
    if raw_dir:
        command += " -p %s" % str(raw_dir)
    if debug:
        command += " -d"
    if exact:
        command += " -e"
    if whole:
        command += " -X"
    if border:
        command += " -b %s" % str(border)
    if restart_rec:
        command += " -r %s" % str(restart_rec)
    if status_file:
        command += " -s %s" % str(status_file)
    if scale_column:
        command += " -x %s" % str(scale_column)
    command += " " + str(images_table)
    command += " " + str(template_header)
    command += " " + str(proj_dir)
    command += " " + str(stats_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mProjExec", p.stdout.read().strip())


def mPutHdr(in_image, out_image, template_header, debug=False,
          status_file=None, hdu=None):
    '''
    Replaces the header of the input file with one supplied by the user.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file.

        *out_image* [ value ]
            Path to output FITS file (with new header)

        *template_header* [ value ]
            ASCII header template to write into out_image.

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging to the specified level (this version only
            supports level "1").

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout

        *hdu* [ value ]
            Write to the specified FITS extnension (HDU).
    '''
    command = "mPutHdr"
    if debug:
        command += " -d"
    if status_file:
        command += " -s %s" % str(status_file)
    if hdu:
        command += " -h %s" % str(hdu)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(template_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mPutHdr", p.stdout.read().strip())


def mRotate(in_image, out_image, debug_level=None, status_file=None,
          rotation_angle=None, ra=None, dec=None, xsize=None, ysize=None):
    '''
    Rotates a FITS image by an arbitrary angle.  This module is meant for
    quick-look only; it is not flux conserving.

    Required Arguments:

        *in_image* [ value ]
            Input FITS image.

        *out_image* [ value ]
            Path to output (rotated) FITS image.

    Optional Arguments:

        *debug_level* [ value ]
            Print out additional debugging information (level can be 1-3)

        *status_file* [ value ]
            Output and errors are written to status_file instead of stdout.

        *rotation_angle* [ value ]
            Provide an angle (in degrees) to rotate the image.

        *ra, dec, xsize* [ value ]
            Center location and width (in degrees) of output image - optional.
            By default, entire input image area will be included in output
            image.

        *ysize* [ value ]
            Height (in degrees) of output image, if a new center location and
            width are provided. Only used if ra, dec, and xsize are specified.
            Defaults to xsize.
    '''
    command = "mRotate"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    if rotation_angle:
        command += " -r %s" % str(rotation_angle)
    command += " " + str(in_image)
    command += " " + str(out_image)
    if ra and dec and xsize:
        command += " %s" % str(ra)
        command += " %s" % str(dec)
        command += " %s" % str(xsize)
        if ysize:
            command += " %s" % str(ysize)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mRotate", p.stdout.read().strip())


def mShrink(in_image, out_image, factor, fixed_size=False, debug_level=None,
          status_file=None):
    '''
    A utility for reducing the size of a FITS file, by averaging blocks of
    pixels.

    Required Arguments:

        *in_image* [ value ]
            Input FITS file

        *out_image* [ value ]
            Path to output FITS file.

        *factor* [ value ]
            Size of blocks, in pixels, to average. File size will be reduced
            by 1/factor squared. If the fixed_size option is used, factor is
            the desired width of the output image.

    Optional Arguments:

        *fixed_size* [ True | False ]
            Fixed-size option - specify output size of image, instead of the
            size of blocks of pixels to be averaged

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-4).

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mShrink"
    if fixed_size:
        command += " -f"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(factor)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mShrink", p.stdout.read().strip())


def mSubimage(in_image, out_image, ra, dec, xsize, debug=False,
          all_pixels=False, hdu=None, status_file=None, ysize=None):
    '''
    Creates a subimage (or "cutout") of a FITS file. To use mSubimage in
    'pixel' mode, see mSubimage_pix

    Required Arguments:

        *in_image* [ value ]
            Input FITS file.

        *out_image* [ value ]
            Path to output FITS file.

        *ra* [ value ]
            RA of center of output image.

        *dec* [ value ]
            Declination of center of output image.

        *xsize* [ value ]
            Width of output image in degrees.

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging.

        *all_pixels* [ True | False ]
            All pixels - Force retrieval of whole image (useful to extract an
            entire HDU)

        *hdu* [ value ]
            Operate on the specified FITS header extension (HDU)

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout

        *ysize* [ value ]
            Height of output image in degrees (default is equal to xsize.
    '''
    command = "mSubimage"
    if debug:
        command += " -d"
    if all_pixels:
        command += " -a"
    if hdu:
        command += " -h %s" % str(hdu)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(ra)
    command += " " + str(dec)
    command += " " + str(xsize)
    if ysize:
        command += " %s" % str(ysize)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mSubimage", p.stdout.read().strip())


def mSubimage_pix(in_image, out_image, xstartpix, ystartpix, xpixsize,
          debug=False, hdu=None, status_file=None, ypixsize=None):
    '''
    Creates a subimage (or "cutout") of a FITS file ('pixel' mode)

    Required Arguments:

        *in_image* [ value ]
            Input FITS file.

        *out_image* [ value ]
            Path to output FITS file.

        *xstartpix* [ value ]
            Pixel along the x-axis where the cutout image will begin

        *ystartpix* [ value ]
            Pixel along the y-axis where the cutout image will begin

        *xpixsize* [ value ]
            Width of output image in pixels

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging.

        *hdu* [ value ]
            Operate on the specified FITS header extension (HDU)

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout

        *ypixsize* [ value ]
            Height of output image in pixels (default is equal to xpix_size
    '''
    command = "mSubimage -p"
    if debug:
        command += " -d"
    if hdu:
        command += " -h %s" % str(hdu)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(in_image)
    command += " " + str(out_image)
    command += " " + str(xstartpix)
    command += " " + str(ystartpix)
    command += " " + str(xpixsize)
    if ypixsize:
        command += " %s" % str(ypixsize)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mSubimage_pix", p.stdout.read().strip())


def mSubset(images_table, template_header, subset_table, debug_level=None,
          fast_mode=False, status_file=None):
    '''
    Generates a table of images that is a subset of the input table,
    containing only those images that cover the area defined by a given FITS
    header.

    Required Arguments:

        *images_table* [ value ]
            ASCII table (generated by mImgtbl) containing metadata for image
            collection.

        *template_header* [ value ]
            FITS header template defining the area of interest.

        *subset_table* [ value ]
            Path to output table, which will contain only those FITS images
            covering the area defined by template_header.

    Optional Arguments:

        *debug_level* [ value ]
            Turns on debugging to the specified level (1-3).

        *fast_mode* [ True | False ]
            Fast mode - input file must include corners (corners option in
            mImgtbl) to utilize this mode.

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout
    '''
    command = "mSubset"
    if debug_level:
        command += " -d %s" % str(debug_level)
    if fast_mode:
        command += " -f"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(images_table)
    command += " " + str(template_header)
    command += " " + str(subset_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mSubset", p.stdout.read().strip())


def mTANHdr(orig_header, new_header, debug=False, order=None, max_iter=None,
          tolerance=None, status_file=None):
    '''
    Analyzes a template file and determines if there would be an adequate
    equivalent distorted TAN projection, within a specified tolerance, and
    outputs the alternate header. This header can be used in conjunction with
    mProjectPP to produce a TAN plane image. This process is considerably
    faster than projecting with the general purpose tool mProject.

    Required Arguments:

        *orig_header* [ value ]
            Input FITS header

        *new_header* [ value ]
            Path to output header to be created

    Optional Arguments:

        *debug* [ True | False ]
            Print additional debugging information to stdout.

        *order* [ value ]
            Order of output header polynomial focal plane distortions (default
            = 4)

        *max_iter* [ value ]
            Maximum number of iteration attempts to produce header (default =
            50)

        *tolerance* [ value ]
            Distortion tolerance value for acceptable output (default = 0.01)

        *status_file* [ value ]
            Output and errors are written to status_file instead of stdout.
    '''
    command = "mTANHdr"
    if debug:
        command += " -d"
    if order:
        command += " -o %s" % str(order)
    if max_iter:
        command += " -i %s" % str(max_iter)
    if tolerance:
        command += " -t %s" % str(tolerance)
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(orig_header)
    command += " " + str(new_header)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mTANHdr", p.stdout.read().strip())


def mTblSort(in_table, column_name, out_table, debug=False):
    '''
    Sorts a table on numeric values.

    Required Arguments:

        *in_table* [ value ]
            Path to input table

        *column_name* [ value ]
            Name of column to sort on (column must contain numeric values)

        *out_table* [ value ]
            Path to output table

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging
    '''
    command = "mTblSort"
    if debug:
        command += " -d"
    command += " " + str(in_table)
    command += " " + str(column_name)
    command += " " + str(out_table)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mTblSort", p.stdout.read().strip())


def mTileHdr(orig_header, new_header, n_x, n_y, ix, iy, debug=False,
          status_file=None, xpad=None, ypad=None):
    '''
    Takes a header template file and creates another which represents one of a
    regular set of tiles covering the original.  The user specifies the tile
    gridding and which tile is desired.

    Required Arguments:

        *orig_header* [ value ]
            ASCII header template from which to derive tiled headers

        *new_header* [ value ]
            Path to output header

        *n_x* [ value ]
            Number of tiles in the x-direction

        *n_y* [ value ]
            Number of tiles in the y-direction

        *ix* [ value ]
            Integer identifying the x location of the output tile on the grid
            (counting from 0)

        *iy* [ value ]
            Integer identifying the y location of the output tile on the grid
            (counting from 0)

    Optional Arguments:

        *debug* [ True | False ]
            Turns on debugging.

        *status_file* [ value ]
            Output and errors are sent to status_file instead of to stdout

        *xpad* [ value ]
            Number of pixels to overlap tiles in the x direction (default is
            0)

        *ypad* [ value ]
            Number of pixels to overlap tiles in the y direction (default is
            0). Only used if xpad is present.
    '''
    command = "mTileHdr"
    if debug:
        command += " -d"
    if status_file:
        command += " -s %s" % str(status_file)
    command += " " + str(orig_header)
    command += " " + str(new_header)
    command += " " + str(n_x)
    command += " " + str(n_y)
    command += " " + str(ix)
    command += " " + str(iy)
    if xpad:
        command += " %s" % str(xpad)
        if ypad:
            command += " %s" % str(ypad)
    p = subprocess.Popen(shlex.split(command), stdout=subprocess.PIPE,
        stderr=subprocess.PIPE)
    stderr = p.stderr.read()
    if stderr:
        raise Exception(stderr)
    return status.parse_struct("mTileHdr", p.stdout.read().strip())

